# Golang Gin RealWorld Example App - Rebuild Strategy

> Generated by Unwind on 2026-01-16

## Executive Summary

**Original Stack:** Go 1.21+, Gin 1.10, GORM 2.x, SQLite, JWT auth
**Overall Readiness:** 9/10
**Recommended Approach:** This codebase is well-structured and highly suitable for either incremental refactoring or complete rebuild. The high test coverage (90%) and clear layer boundaries make it an excellent candidate for test-driven migration.

---

## Strategic Decisions

### Database Strategy

**Question:** Can we connect to the live database during rebuild?

**Assessment:**
- SQLite database with file-based storage (`./data/gorm.db`)
- Simple schema: 8 tables with straightforward relationships
- No multi-tenancy or complex isolation requirements
- Auto-migration strategy (no versioned migrations to replay)
- GORM ORM abstracts database access

**Recommendation:** **Yes - Direct connection feasible**

The SQLite database can be:
1. Copied for development/testing
2. Accessed directly by rebuilt system during parallel running
3. Migrated to a different database (PostgreSQL, MySQL) with minimal schema changes

**Migration options:**
- [x] Retain SQLite for simplicity
- [ ] Migrate to PostgreSQL for production scalability
- [ ] Use GORM's database-agnostic design to switch drivers

**Reference:** [layers/database/index.md](layers/database/index.md)

### Test Re-usability

**Question:** Can we run existing tests against the rebuilt system?

**Assessment:**
- 90% test coverage across 62 test functions
- Tests are behavior-focused (HTTP endpoints, model operations)
- Table-driven tests provide comprehensive input/output specifications
- Test utilities provide reusable factories and mocking
- Tests use standard Go testing patterns (testify, httptest)

**Recommendation:** **High re-usability with minimal adaptation**

The tests can serve as:
1. **Specification:** Define expected behavior for rebuilt system
2. **Regression suite:** Validate rebuilt system matches original
3. **Migration guide:** Identify all edge cases and error handling

**Adapters needed:**
- [ ] Update import paths if package structure changes
- [ ] Adapt database setup if changing from SQLite
- [ ] Modify token mocking if JWT implementation differs

**Reference:** [layers/unit-tests/index.md](layers/unit-tests/index.md)

### Frontend Retention

**Question:** Can we retain the frontend and replace only the backend?

**Assessment:**
- This is a **backend-only API**
- Designed for RealWorld frontend implementations
- No frontend code exists in this repository

**Recommendation:** **Not applicable**

This codebase implements the RealWorld API specification, which has multiple frontend implementations available. Any rebuild should:
1. Maintain exact API contract compatibility
2. Use the Postman collection for contract testing
3. Test against existing RealWorld frontends

**API Contract:**
- Preserve exactly: All 21 endpoints per RealWorld spec
- Preserve exactly: Response envelope format (`{user: {...}}`, `{article: {...}}`)
- Preserve exactly: JWT token format (`Token <jwt>`)

**Reference:** [layers/api/index.md](layers/api/index.md)

### Integration Preservation

**External Services:**
| Integration | Contract Type | Must Preserve |
|-------------|---------------|---------------|
| None | N/A | N/A |

This is a self-contained application with no external service dependencies.

**Scheduled Jobs:**
| Job | Frequency | Rebuild Approach |
|-----|-----------|------------------|
| None | N/A | N/A |

No scheduled jobs or background workers.

---

## Phasing Strategy

### Phase 1: Foundation

**Retain:**
- Database schema (8 tables) - works as-is
- Test utilities and factories
- API contract definitions (from Postman collection)

**Adapt:**
- Database connection configuration
- Environment variable handling

**Rebuild:**
- Main entry point (`hello.go`) - if changing framework

**Reference:** [layers/database/index.md](layers/database/index.md)

**Validation:**
- [ ] Database connection successful
- [ ] Auto-migration creates all tables
- [ ] Test database setup/teardown works

### Phase 2: Domain Model

**Retain:**
- Entity definitions (7 entities) - can translate directly
- Validation rules (constraints, lengths, formats)
- Unique constraints (email, slug, tag)

**Adapt:**
- GORM-specific tags if changing ORM
- Relationship definitions

**Rebuild:**
- Active Record methods â†’ separate service layer (if desired)

**Reference:** [layers/domain-model/index.md](layers/domain-model/index.md)

**Validation:**
- [ ] All entities map correctly to database tables
- [ ] Relationships work (preloading, joins)
- [ ] Validation rules enforce constraints

### Phase 3: Service Layer

**Retain:**
- Business logic specifications (22 service methods)
- Authorization rules (owner checks)
- N+1 prevention patterns (batch queries)

**Adapt:**
- Refactor from Active Record to Repository pattern (if desired)
- Extract service layer from model methods

**Rebuild:**
- Consider explicit service classes instead of model methods

**Reference:** [layers/service-layer/index.md](layers/service-layer/index.md)

**Validation:**
- [ ] Password hashing compatible with existing data
- [ ] JWT tokens interoperable with existing system
- [ ] All CRUD operations work correctly

### Phase 4: API Layer

**Retain:**
- Route structure (21 endpoints)
- Request/response contracts (RealWorld spec)
- Error response format (CommonError)

**Adapt:**
- Framework-specific routing (if changing from Gin)
- Middleware patterns

**Rebuild:**
- Consider OpenAPI specification generation
- Add request logging, rate limiting, CORS

**Reference:** [layers/api/index.md](layers/api/index.md)

**Validation:**
- [ ] All endpoints respond correctly
- [ ] Authentication works (required/optional/none)
- [ ] Validation errors match expected format

### Phase 5: Validation & Cutover

**Parallel Running Strategy:**
- Run both systems against same database
- Compare responses for identical requests
- Use Postman collection for automated testing

**Cutover triggers:**
- All 62 tests pass
- Postman collection runs successfully
- No discrepancies in parallel comparison

---

## Validation Strategy

### Equivalence Testing

**Approach:** Use existing test suite as the primary validation mechanism

**Test Vectors:**
- [ ] All 62 unit tests pass against rebuilt system
- [ ] Postman collection (`api/Conduit.postman_collection.json`) runs successfully
- [ ] Password verification works for existing user accounts
- [ ] JWT tokens from original system validate in rebuilt system

### Coverage Requirements

| Area | Minimum Coverage | Current |
|------|------------------|---------|
| common | 85% | 85.7% |
| users | 99% | 99.5% |
| articles | 93% | 93.4% |
| **Overall** | **90%** | **90.0%** |

### Go-Live Checklist

- [ ] All phase validations complete
- [ ] Test coverage maintained at 90%+
- [ ] Postman collection passing
- [ ] Password compatibility verified
- [ ] JWT interoperability confirmed
- [ ] Performance benchmarks acceptable

---

## Security Considerations

**Must Address in Rebuild:**

| Issue | Current State | Recommendation |
|-------|---------------|----------------|
| JWT Secret | Hardcoded | Move to environment variable |
| Rate Limiting | None | Add rate limiting middleware |
| CORS | Not configured | Add CORS configuration |
| Password Complexity | Length only | Consider complexity rules |

**Reference:** [layers/api/index.md](layers/api/index.md) - Unknowns section

---

## Layer Documentation References

> **Note:** These documents contain the detailed specifications. This plan focuses on strategic decisions only.

| Layer | Reference | Readiness |
|-------|-----------|-----------|
| Database | [layers/database/index.md](layers/database/index.md) | 9/10 |
| Domain Model | [layers/domain-model/index.md](layers/domain-model/index.md) | 9/10 |
| Service Layer | [layers/service-layer/index.md](layers/service-layer/index.md) | 8/10 |
| API | [layers/api/index.md](layers/api/index.md) | 9/10 |
| Unit Tests | [layers/unit-tests/index.md](layers/unit-tests/index.md) | 10/10 |

**Overall Assessment:** This codebase is exceptionally well-documented with high test coverage. The clear separation of concerns and adherence to the RealWorld specification makes it an ideal candidate for migration or refactoring.
